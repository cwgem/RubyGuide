= RSpec In Practice =
:Author: @ukstudio (Translator: @cwgem )
:Date: September 28th 2011
:Source: http://jp.rubyist.net/magazine/?0035-RSpecInPractice

[NOTE]
This document is a translation of a Japanese article by ukstudio on the topic of writing RSpec tests. It was published in http://jp.rubyist.net/magazine/?0035-RSpecInPractice[Rubyist Magazine Volume 35]. 

== Introduction ==

This article is meant to serve as an exploration of the RSpec testing framework. It is not intended to be an introduction, but rather aimed at presenting relatively practical uses. With this in mind, the article targets those who are at minimum familiar with `it`, `describe`, and testing fundamentals in general.

[NOTE]
I've left out the translation of the second paragraph as it targets Japan users specifically and does not make sense to have in the context of a translation targeted towards English-speaking users.

This article hopes to further increase the amount of RSpec documentation available by teaching RSpec usage to those interested, and those who are using it but feel they haven't mastered it properly.

== From xUnit Like Code To RSpec Style ==

=== xUnit like RSpec code ===

"xUnit like code" is essentially code that does not properly utilize RSpec features, and treats `it` the same as xUnit test methods.

[source,ruby]
-----
describe Stack do
  before do
    @stack = Stack.new
  end

  it 'the return value of #push should equal the pushed value' do
    @stack.push('value').should eq 'value'
  end
  it 'when the stack is empty, #pop should return nil' do
    @stack.pop.should be_nil
  end

  it 'When the stack contains values, #pop returns the last value' do
    @stack.push 'value1'
    @stack.push 'value2'
    @stack.pop.should eq 'value2'
    @stack.pop.should eq 'value1'
  end

  it '#size returns the size of the stack' do
    @stack.size.should eq 0

    @stack.push 'value'
    @stack.size.should eq 1
  end
end
-----

The above test code is written using RSpec to test stack construction through the `Stack` class. `Stack` has 3 methods, `push`, `pop`, and `size`.

xUnit generally has test methods defined in a more flat manner (though this style has been changing as of late), so one could consider this code to be "xUnit like". The test method is simply rewritten to use `it` instead, and the `before` block is used like a `setup` method.

=== describe and context ===

Now it's time to take the code and make a few adjustments to it. First off will be the usage of `describe`. While there should always be at least one `describe` present, it is possible to have them at the same level, or even nested.

[source,ruby]
-----
describe Stack do
  before do
    @stack = Stack.new
  end

  describe '#push' do
    it 'returns the pushed value' do
      @stack.push('value').should eq 'value'
    end

    it 'throws an exception if nil is pushed' do
      lambda { @stack.push(nil) }.should raise_error(ArgumentError)
    end
  end

  describe '#pop' do
    it 'when the stack is empty, #pop will return nil' do
      @stack.pop.should be_nil
    end

    it 'when the stack contains values, #pop will return the last value' do
      @stack.push 'value1'
      @stack.push 'value2'
      @stack.pop.should eq 'value2'
      @stack.pop.should eq 'value1'
    end
  end

  describe '#size' do
    it '#size returns the size of the stack' do
      @stack.size.should eq 0

      @stack.push 'value'
      @stack.size.should eq 1
    end
  end
end
-----

Using `describe` helps to establish structure in the test code. Because each and every test case is grouped, it makes it easier to understand what the functionality is being tested. 

Next is the usage of `context`. `context` is just an alias for `describe`, but it serves a different purposes. To put it simply, `describe` is meant to indicate what is being tested, while `context` is meant to describe the state of the test when it is run.

[source,ruby]
-----
describe Stack do
  before do
    @stack = Stack.new
  end
  describe '#push' do
    context 'normal value' do
      it 'returns the pushed value' do
        @stack.push('value').should eq 'value'
      end
    end

    context 'nil is pushed' do
      it 'throws an exception' do
        lambda { @stack.push(nil) }.should raise_error(ArgumentError)
      end
    end
  end

  describe '#pop' do
    context 'the stack is empty' do
      it 'nil is returned' do
        @stack.pop.should be_nil
      end
    end

    context 'the stack contains values' do
      it 'the last value is returned' do
        @stack.push 'value1'
        @stack.push 'value2'
        @stack.pop.should eq 'value2'
      end
    end
  end

  describe '#size' do
    it 'returns the size of the stack' do
      @stack.size.should eq 0

      @stack.push 'value'
      @stack.size.should eq 1
    end
  end
end
-----

In this case, `describe` is used to categorize tests by individual methods. The reason for this being that test cases are generally written to target specific methods, so this separation makes writing tests easier to manage. It also has the added benefit of being easier to read.

However, there are times when the target of the tests are not methods alone. Often times communication between several objects is being tested. In this case the user should use `describe` in a manner that is easiest for them to understand. One mustn't take too much time fussing over method separation.

=== Step by step technical specifications in test code ===

I personally believe that the general concept behind `describe` and `context` is extremely important. This is because it has the capability to be used as a tool to lay out technical specifications through test code. 

For example, when writing test code for the `Stack` class, the general thought process would start with the implementation of methods. First is the push method implementation:

[source,ruby]
-----
describe Stack do
  describe '#push' do
  end
end
-----

Now that there is a method to work with, the next step is thinking about how to call the method. In the case of `push`, the first case is the storage the value passed in. First the test case is written using `it`, disregarding for now any other `context`:

[source,ruby]
-----
describe Stack do
  describe '#push' do
    it 'stores the value'
  end
end
-----

When considering proper values to pass in, it is also important to consider improper values. For example, when `nil` is passed in an exception is thrown. Since this situation is different from that of a proper value, `context` must be utilized:

[source,ruby]
-----
describe Stack do
  describe '#push' do
    context 'proper value' do
      it 'stores the value'
    end

    context 'nil value' do
      it 'throws an exception'
    end
  end
end
-----

In this way `describe`, `context`, and `it` are utilized in sequential order to provide step by step test code to present technical specifications. The usage of `describe` and `context` to organize application specification helps ease the design process.

=== subject ===

In RSpec when `subject` is used the receiver of `should` can be omitted. Rewriting the previous code to use `subject` gives:

[source,ruby]
-----
describe '#pop' do
  subject { @stack.pop }
  
  context 'the stack is empty' do
    it 'returns nil' do
      should be_nil
    end
  end
  
  context 'the stack contains values' do
    before do
      @stack.push 'value1'
      @stack.push 'value2'
    end
    
    it 'returns the last value' do
      should eq 'value2'
    end
  end
end
-----

The merit of `subject` is that it clearly indicates the target of the test, and it requires that a single test case can only contain a single assertion. When writing a test, it puts importance on the awareness about what is currently being tested. While `describe` tends to be very clear in intentions, `subject` is a bit weak in comparison. `subject` helps to split out often generally vague sections, such as whether the state of an object after method invocation, or the return of a method is being tested.

[source,ruby]
-----
describe Array, '#delete' do
  subject { [1,2,3].delete(3) }
  it { should eq 3 }
end

describe Array, '#delete' do
  before do
    @array = [1,2,3]
    @array.delete(3)
  end
  subject { @array }
  its(:size) { should eq 2 }
end
-----

As the code shows, the usage of `subject` makes it so there is only one assertion per test case. In general it's a good idea to have one assertion per test case, and using `subject` makes it more natural to write them as such.

=== subject and nested describe ===

There are cases in which a test will want to work with a related object that was previously tested. For example, a `User` class with a related `Profile` class. In this case, if `subject` is used to omit the receiver of `should`, it won't be possible to access the related object. To resolve this issue a nested `describe` can be used with another `subject` declaration.

[source,ruby]
-----
describe User, '#create!' do
  before { @user=User.create! }
  subject { @user }
  it { should_not be_new_record }
  
  describe Profile do
    subject { @user.profile }
    it { should_not be_new_record }
    its(:name) { should eq 'AKAMATSU Yuki' }
  end
end
-----

In this way it is possible to test a related object from a previous test. This situation is fairly common for those developing Rails applications. 

Another solution is to use `its`, which is useful when there are few areas which require testing.

[source,ruby]
-----
describe User, '#create!' do
  subject { User.create! }
  it { should_not be_new_record }
  its(:profile) { should_not be_new_record }
  its('profile.name') { should eq 'AKAMATSU Yuki' }
end
-----

=== Passing or not passing strings to it ===

Now then, some of you may have already noticed that the style of how the tests were written changed throughout the article. For instance, `it` can have the string passed to it omitted. When used this way RSpec code such as "it should be nil" can be read like a normal English sentence. 

A common debate regarding RSpec usage is whether or not to pass a string to `it`. I notice that users who tend to constantly use the most up to date versions of RSpec often lean towards leaving out the string. Personally I usually leave the string out and let the RSpec code itself express the tests.

The reason for this is that passing a string to `it` has a similar problem to lacking separation between code and comments. One of the recent trends in writing of good code is the principle of "writing code that can be understood without relying on comments." The logic is that when dealing with code and comments, just modifying one leaves the other inconsistent, violating the principle of DRY (Don't Repeat Yourself). 

The same can be said about RSpec's `it` and passing a string to it. Situations where the string passed to `it` being left as is while the test code is modified happens quite often. Also by constantly passing strings to `it`, the test code becomes much longer.

However, that is not to say that leaving the string out is without problems. For instance, the documentation produced by RSpec's `--format documentation` can become more difficult to read. As an example, in the code from the `Stack` class the "returns the last value" code becomes "should eq 'value1'". This makes it impossible to discern the specification being tested.

[source,text]
-----
Stack
   #pop
     the stack is empty
       returns nil
     the stack contains values
       returns the last value
-----

[source,text]
-----
Stack
   #pop
     the stack is empty
       should be nil
     the stack contains values
       should == value2
-----

There are a few ways to solve this. One of them is to explicitly indicate the value using `context`. The other is to define a custom matcher.

[source,ruby]
-----
RSpec::Matchers.define :be_latest_value do |expected|
  match do |actual|
    actual == latest_value
  end
end

describe Stack do
  before { @stack = Stack.new }
  describe '#pop' do
    subject { @stack.pop }

    context 'the stack is empty' do
      it { should be_nil }
    end

    # Explicitly indicate the value with context
    context 'the last value of the stack is "value2"' do
      before do
        @stack.push 'value1'
        @stack.push 'value2'
      end

      it { should eq 'value2' }
    end

    # Adjust the meaning with a custom matcher
    context 'The stack contains values' do
      let(:latest_value) { 'value2' }
      before do
        @stack.push 'value1'
        @stack.push latest_value
      end

      it { should be_latest_value }
    end
  end
end
-----

[source,text]
-----
Stack
   #pop
     the stack is empty
       should be nil
     the last value of the stack is "value2"
       should == value2
     the stack contains values
       should be latest value
-----

By using `context` to explicitly declare the value, it is easier to discern that RSpec's output means the last value will be returned. Using a customer matcher, the code will be output as is and is even easier to read.

However, I personally don't take it this far. At most I would worry about the wording of `context`. The reason being that as a programmer, reading the test code is more important than reading the documentation. With this in mind it would not seem reasonable to just read the RSpec output alone. This is why I'm less concerned about sentences in the output looking odd as long as the test code is easy to read.

In conclusion, I recommend using `it` without passing in a string. The strongest reason for this being that mixing strings and test code violates the DRY principle. Also the samples given here are small so the issue with size is not as apparent. However it's normal for test cases to be much more numerous. In these cases leaving out the string results in more compact test code.

While I recommend omitting the string, there are those who feel it is more natural to not do so. You should use your best judgement and what is most comfortable to decide which method you agree with. Both have advantages and disadvantages, there is no strictly correct answer.

=== Data sharing with let ===

In RSpec there is a function known as `let`. Compared to `subject` and other features, the usage is hard to grasp for a lot of users, so I'll attempt to explain its usage. 

[source,ruby]
-----
describe 'let' do
  let(:foo) { 'foo' }
  specify { foo.should eq 'foo' }
end
-----

`let` takes the evaluation result of the block passed in, then stores the result in a variable of the same name as the symbol name given in the argument. In the above example, the evaluation result of the block is "foo" and the symbol name is `:foo`, so "foo" will be stored in a variable named `foo`. This method utilizes lazy evaluation, so the block won't be evaluated unless explicitly called. Results of the block evaluation will be cached and accessible within the same test case, ensuring that multiple calls will not produce multiple evaluations of the block.

When writing tests, there are often cases where the methods being called are the same, but data is slightly different. Previously this was addressed through writing out the same processing code using `before` inside of `describe` and `context`. Now that there's `let`, we can be a little smarter about how the code is written.

[source,ruby]
-----
describe User, '#admin?' do
  before do
    @user = User.new(:name => 'jack')
  end
  subject { @user }
  
  context 'admin' do
    before do
      @user.role = Role.new(:role => :admin)
    end

    it { should be_admin }
  end
  
  context 'not admin' do
    before do
      @user.role = Role.new(:role => :normal)
    end
    
    it { should_not be_admin }
  end
end
-----

The `User` class contains a `Role` class, and the return value of the `admin?` method changes depending on the state of the `Role`. This code was written without the use of `let`, instead utilizing `before` and `subject`. The `context` of `admin` and `not admin` differ solely in the arguments passed to the `Role` class constructor.

[source,ruby]
-----
describe User, '#admin?' do
  before do
    @user = User.new(:name => 'jack')
    @user.role = Role.new(:role => role)
  end
  subject { @user }
  
  context 'admin' do
    let(:role) { :admin }
    it { should be_admin }
  end
  
  context 'not admin' do
    let(:role) { :normal }
    it { should_not be_admin }
  end
end
-----

Since `let` in this manner allows for separation of data, `Role` initialization of can be moved to a single `before`. Compared to the previous code, this version adheres more closely to the DRY principle. It can be considered a more orthodox approach to using `let`.

Of course, `let` can also be used as a simple replacement of instance variables. While this is somewhat a matter of preference, the definition of data can be written more declaratively, making the test code easier to read.

[source,ruby]
-----
describe Stack, '#pop' do
  let(:stack) { Stack.new }
  subject { stack.pop }
  
  context 'the stack is empty' do
    it { should be_nil }
  end
  
  context 'the stack contains values' do
    let(:oldest_value) { 'value1' }
    let(:latest_value) { 'value2' }

    before do
      stack.push oldest_value
      stack.push latest_value
    end

    it { should eq latest_value }
  end
end
-----
