= RSpec In Practice =
:Author: @ukstudio (Translator: @cwgem )
:Date: September 28th 2011
:Source: http://jp.rubyist.net/magazine/?0035-RSpecInPractice

[NOTE]
This document is a translation of a Japanese article by ukstudio on the topic of writing RSpec tests. It was published in http://jp.rubyist.net/magazine/?0035-RSpecInPractice[Rubyist Magazine Volume 35]. 

== Introduction ==

This article is meant to serve as an exploration of the RSpec testing framework. It is not intended to be an introduction, but rather aimed at presenting relatively practical uses. With this in mind, the article targets those who are at minimum familiar with `it`, `describe`, and testing fundamentals in general.

[NOTE]
I've left out the translation of the second paragraph as it targets Japan users specifically and does not make sense to have in the context of a translation targeted towards English-speaking users.

This article hopes to further increase the amount of RSpec documentation available by teaching RSpec usage to those interested, and those who are using it but feel they haven't mastered it properly.

== From xUnit Like Code To RSpec Style ==

=== xUnit like RSpec code ===

"xUnit like code" is essentially code that does not properly utilize RSpec features, and treats `it` the same as xUnit test methods.

[source,ruby]
-----
describe Stack do
  before do
    @stack = Stack.new
  end

  it 'the return value of #push should equal the pushed value' do
    @stack.push('value').should eq 'value'
  end
  it 'when the stack is empty, #pop should return nil' do
    @stack.pop.should be_nil
  end

  it 'When the stack contains values, #pop returns the last value' do
    @stack.push 'value1'
    @stack.push 'value2'
    @stack.pop.should eq 'value2'
    @stack.pop.should eq 'value1'
  end

  it '#size returns the size of the stack' do
    @stack.size.should eq 0

    @stack.push 'value'
    @stack.size.should eq 1
  end
end
-----

The above test code is written using RSpec to test stack construction through the `Stack` class. `Stack` has 3 methods, `push`, `pop`, and `size`.

xUnit generally has test methods defined in a more flat manner (though this style has been changing as of late), so one could consider this code to be "xUnit like". The test method is simply rewritten to use `it` instead, and the `before` block is used like a `setup` method.

=== describe and context ===

Now it's time to take the code and make a few adjustments to it. First off will be the usage of `describe`. While there should always be at least one `describe` present, it is possible to have them at the same level, or even nested.

[source,ruby]
-----
describe Stack do
  before do
    @stack = Stack.new
  end

  describe '#push' do
    it 'returns the pushed value' do
      @stack.push('value').should eq 'value'
    end

    it 'throws an exception if nil is pushed' do
      lambda { @stack.push(nil) }.should raise_error(ArgumentError)
    end
  end

  describe '#pop' do
    it 'when the stack is empty, #pop will return nil' do
      @stack.pop.should be_nil
    end

    it 'when the stack contains values, #pop will return the last value' do
      @stack.push 'value1'
      @stack.push 'value2'
      @stack.pop.should eq 'value2'
      @stack.pop.should eq 'value1'
    end
  end

  describe '#size' do
    it '#size returns the size of the stack' do
      @stack.size.should eq 0

      @stack.push 'value'
      @stack.size.should eq 1
    end
  end
end
-----

Using `describe` helps to establish structure in the test code. Because each and every test case is grouped, it makes it easier to understand what the functionality is being tested. 

Next is the usage of `context`. `context` is just an alias for `describe`, but it serves a different purposes. To put it simply, `describe` is meant to indicate what is being tested, while `context` is meant to describe the state of the test when it is run.

[source,ruby]
-----
describe Stack do
  before do
    @stack = Stack.new
  end
  describe '#push' do
    context 'normal value' do
      it 'returns the pushed value' do
        @stack.push('value').should eq 'value'
      end
    end

    context 'nil is pushed' do
      it 'throws an exception' do
        lambda { @stack.push(nil) }.should raise_error(ArgumentError)
      end
    end
  end

  describe '#pop' do
    context 'the stack is empty' do
      it 'nil is returned' do
        @stack.pop.should be_nil
      end
    end

    context 'the stack contains values' do
      it 'the last value is returned' do
        @stack.push 'value1'
        @stack.push 'value2'
        @stack.pop.should eq 'value2'
      end
    end
  end

  describe '#size' do
    it 'returns the size of the stack' do
      @stack.size.should eq 0

      @stack.push 'value'
      @stack.size.should eq 1
    end
  end
end
-----

In this case, `describe` is used to categorize tests by individual methods. The reason for this being that test cases are generally written to target specific methods, so this separation makes writing tests easier to manage. It also has the added benefit of being easier to read.

However, there are times when the target of the tests are not methods alone. Often times communication between several objects is being tested. In this case the user should use `describe` in a manner that is easiest for them to understand. One mustn't take too much time fussing over method separation.

=== Step by step technical specifications in test code ===

I personally believe that the general concept behind `describe` and `context` is extremely important. This is because it has the capability to be used as a tool to lay out technical specifications through test code. 

For example, when writing test code for the `Stack` class, the general thought process would start with the implementation of methods. First is the push method implementation:

[source,ruby]
-----
describe Stack do
  describe '#push' do
  end
end
-----

Now that there is a method to work with, the next step is thinking about how to call the method. In the case of `push`, the first case is the storage the value passed in. First the test case is written using `it`, disregarding for now any other `context`:

[source,ruby]
-----
describe Stack do
  describe '#push' do
    it 'stores the value'
  end
end
-----

When considering proper values to pass in, it is also important to consider improper values. For example, when `nil` is passed in an exception is thrown. Since this situation is different from that of a proper value, `context` must be utilized:

[source,ruby]
-----
describe Stack do
  describe '#push' do
    context 'proper value' do
      it 'stores the value'
    end

    context 'nil value' do
      it 'throws an exception'
    end
  end
end
-----

In this way `describe`, `context`, and `it` are utilized in sequential order to provide step by step test code to present technical specifications. The usage of `describe` and `context` to organize application specification helps ease the design process.

=== subject ===

In RSpec when `subject` is used the receiver of `should` can be omitted. Rewriting the previous code to use `subject` gives:

[source,ruby]
-----
describe '#pop' do
  subject { @stack.pop }
  
  context 'the stack is empty' do
    it 'returns nil' do
      should be_nil
    end
  end
  
  context 'the stack contains values' do
    before do
      @stack.push 'value1'
      @stack.push 'value2'
    end
    
    it 'returns the last value' do
      should eq 'value2'
    end
  end
end
-----

The merit of `subject` is that it clearly indicates the target of the test, and it requires that a single test case can only contain a single assertion. When writing a test, it puts importance on the awareness about what is currently being tested. While `describe` tends to be very clear in intentions, `subject` is a bit weak in comparison. `subject` helps to split out often generally vague sections, such as whether the state of an object after method invocation, or the return of a method is being tested.

[source,ruby]
-----
describe Array, '#delete' do
  subject { [1,2,3].delete(3) }
  it { should eq 3 }
end

describe Array, '#delete' do
  before do
    @array = [1,2,3]
    @array.delete(3)
  end
  subject { @array }
  its(:size) { should eq 2 }
end
-----

As the code shows, the usage of `subject` makes it so there is only one assertion per test case. In general it's a good idea to have one assertion per test case, and using `subject` makes it more natural to write them as such.

=== subject and nested describe ===

There are cases in which a test will want to work with a related object that was previously tested. For example, a `User` class with a related `Profile` class. In this case, if `subject` is used to omit the receiver of `should`, it won't be possible to access the related object. To resolve this issue a nested `describe` can be used with another `subject` declaration.

[source,ruby]
-----
describe User, '#create!' do
  before { @user=User.create! }
  subject { @user }
  it { should_not be_new_record }
  
  describe Profile do
    subject { @user.profile }
    it { should_not be_new_record }
    its(:name) { should eq 'AKAMATSU Yuki' }
  end
end
-----

In this way it is possible to test a related object from a previous test. This situation is fairly common for those developing Rails applications. 

Another solution is to use `its`, which is useful when there are few areas which require testing.

[source,ruby]
-----
describe User, '#create!' do
  subject { User.create! }
  it { should_not be_new_record }
  its(:profile) { should_not be_new_record }
  its('profile.name') { should eq 'AKAMATSU Yuki' }
end
-----


